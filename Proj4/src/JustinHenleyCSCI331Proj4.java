/*
Project 4:      Performance of Page Replacement Algorithms
Description:    Compares the performance of page replacement algorithms for fixed numbers of frames: Optimal, FIFO, LRU, Second Chance
Author:         Justin Henley, jahenley@mail.fhsu.edu
Date:           2021-05-06
 */

import java.util.*;

public class JustinHenleyCSCI331Proj4 {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int sizeOfVM, lengthOfRS, sizeOfLocus, rateOfMotion, numOfFrames;
        double prob;
        char choice;

        do {
            // Get user spec for test run
            System.out.println("Enter size of virtual memory: ");
            sizeOfVM = input.nextInt();
            System.out.println("Enter length of reference string: ");
            lengthOfRS = input.nextInt();
            System.out.println("Enter size of locus: ");
            sizeOfLocus = input.nextInt();
            System.out.println("Enter rate of motion: ");
            rateOfMotion = input.nextInt();
            System.out.println("Enter probability of transition: ");
            prob = input.nextDouble();
            System.out.println("Enter number of frames: ");
            numOfFrames = input.nextInt();

            // Create the new reference string
            ArrayList<Integer> rs = createRS(sizeOfVM, lengthOfRS, sizeOfLocus, rateOfMotion, prob);

            // Report results
            int fifo = FIFOReplacement(rs, numOfFrames);
            int lru = LRUReplacement(rs, numOfFrames);
            int optimal = OptimalReplacement(rs, numOfFrames);
            int secondChance = SecondChanceReplacement(rs, numOfFrames);
            displayResults(optimal, lru, secondChance, fifo);

            // Prompt for continuation
            System.out.println("Do you want to run another test? Y/N");
            input.nextLine();  // Clear out newline character left in stream
            choice = input.nextLine().toUpperCase().charAt(0);  // Take new input from user
            System.out.println();
        } while(choice == 'Y');
    }

    /**
     * Creates a reference string built to the given specifications
     *
     * @param sizeOfVM Size of the virtual memory
     * @param length Length of the reference string to generate
     * @param sizeOfLocus Size of the locus
     * @param rateOfMotion Rate of Motion
     * @param prob Probability of a transition to a new location
     * @return An ArrayList of integers representing the reference string
     */
    private static ArrayList<Integer> createRS(int sizeOfVM, int length, int sizeOfLocus, int rateOfMotion, double prob) {
        // Create a new array list to store the reference string (RS)
        ArrayList<Integer> result = new ArrayList<>();
        int start = 0;
        int n;  // A page number in a reference string, declared out here for persistence across while iterations

        // Repeat until desired size is reached
        while(result.size() < length) {
            // Add size of locus random number in it
            for (int i = 0; i < rateOfMotion; i++) {
                n = (int) (Math.random() * sizeOfLocus + start);
                result.add(n);
            }
            // Generate a random number between 0 and 1 to decide whether to transition
            if (Math.random() < prob)
                start = (int) (Math.random() * sizeOfVM);
            else
                start = (start + 1) % sizeOfVM;
        }
        return result;
    }

    /**
     * Reports the number of page replacements after applying the FIFO
     * replacement algorithm to the given reference string
     * @param rs The reference string to with the algorithm is applied
     * @param numOfFrames The number of frames in memory
     * @return The number of page faults generated by the algorithm
     */
    private static int FIFOReplacement(ArrayList<Integer> rs, int numOfFrames) {
        // All frames are empty
        int[] frames = new int[numOfFrames];
        // Index of oldest frame, count of page faults
        int oldest = 0, numPageFaults = 0;

        // No pages loaded yet
        Arrays.fill(frames, -1);

        for (Integer r : rs) {
            // Page fault
            if (isInArray(frames, r) == -1) {
                frames[oldest] = r;  // Copy new page into oldest page frame
                numPageFaults++;  // Record this page fault
                // Frames should be added sequentially, thus the next-oldest frame is the next one in the list
                oldest = (oldest + 1) % (frames.length);
            }
        }

        return numPageFaults;
    }

    /**
     * Reports the number of page replacements after applying the LRU
     * replacement algorithm to the given reference string
     * @param rs The reference string to with the algorithm is applied
     * @param numOfFrames The number of frames in memory
     * @return The number of page faults generated by the algorithm
     */
    private static int LRUReplacement(ArrayList<Integer> rs, int numOfFrames) {
        // All frames are empty
        int[] frames = new int[numOfFrames];
        // Count of the number of page faults
        int numPageFaults = 0;

        // No pages loaded yet
        Arrays.fill(frames, -1);

        for (Integer r : rs) {
            int index = isInArray(frames, r);
            int most;  // most recently used page

            if (index == -1) {  // Page fault
                most = r;
                numPageFaults++;
                index = 0;  // The first (least recently used) element will be removed
            } else
                most = frames[index];  // The page that is most recently moved shall get moved to the end

            // Shifts right side of array left, overwriting the position to be removed. Leaves last position unmodified
            if (frames.length - 1 - index >= 0)
                System.arraycopy(frames, index + 1, frames, index, frames.length - 1 - index);
            // Adds the most recently used page to the end of the list, overwriting previous value
            frames[frames.length - 1] = most;
        }

        return numPageFaults;
    }

    /**
     * Reports the number of page replacements after applying the Optimal
     * replacement algorithm to the given reference string
     * @param rs The reference string to with the algorithm is applied
     * @param numOfFrames The number of frames in memory
     * @return The number of page faults generated by the algorithm
     */
    private static int OptimalReplacement(ArrayList<Integer> rs, int numOfFrames) {
        // All frames are empty
        int[] frames = new int[numOfFrames];
        // Count of the number of page faults
        int numPageFaults = 0;

        // No pages loaded yet
        Arrays.fill(frames, -1);

        // Iterate over entire reference string.  Used traditional for loop to access index for forward-search
        for (int pos = 0; pos < rs.size(); pos++) {
            // Page fault
            if (isInArray(frames, rs.get(pos)) == -1) {
                // Create sublist of future references to search
               List<Integer> futureRS = rs.subList(pos, rs.size());

               int furthestFrameIndex = 0;
               int furthestFrameDistance = 0;

               // Check all frames for page referenced furthest in the future
               // If a page is never referenced, it sets distance to -1 to exit search and replace that page in memory
                for (int f = 0; f < frames.length && furthestFrameDistance != -1; f++) {
                    int page = frames[f];
                    int nextReference = futureRS.indexOf(page);

                    // If no future reference occurs, this can be considered the furthest reference
                    if (nextReference == -1) {
                        furthestFrameIndex = f;
                        furthestFrameDistance = -1;
                    }
                    // If a future reference is found, check if it s the furthest
                    else {
                        // If this is the furthest reference found, record it
                        if (nextReference > furthestFrameDistance) {
                            furthestFrameDistance = nextReference;
                            furthestFrameIndex = f;
                        }
                    }
                }

                // Replace the frame with the furthest subsequent reference in the reference string
                frames[furthestFrameIndex] = rs.get(pos);
                // Record page fault
                numPageFaults++;


            }
        }


        return numPageFaults;
    }

    /**
     * Reports the number of page replacements after applying the Second Chance
     * replacement algorithm to the given reference string
     * @param rs The reference string to with the algorithm is applied
     * @param numOfFrames The number of frames in memory
     * @return The number of page faults generated by the algorithm
     */
    private static int SecondChanceReplacement(ArrayList<Integer> rs, int numOfFrames) {
        // All frames are empty
        int[][] frames = new int[numOfFrames][2];
        // Count of the number of page faults
        int numPageFaults = 0;
        // Pointer to the frame to be considered for replacement
        int replace = 0;

        // No pages loaded yet
        for(int i = 0; i < frames.length; i++) {
            frames[i][0] = -1;
            frames[i][1] = 0;
        }

        for (Integer r : rs) {
            int index = isInArray(frames, r);

            if (index != -1) {
                // If page is found in memory, set r-bit to 1
                frames[index][1] = 1;
            }
            else {  // page is not in memory
                numPageFaults++;  // Record page fault

                // Iterate until a frame is found where r-bit is 0
                while (frames[replace][1] == 1) {
                    frames[replace][1] = 0;
                    replace = (replace + 1) % frames.length;
                }

                // Once a suitable frame is found, replace
                frames[replace][0] = r;
                frames[replace][1] = 0;

                // Increment replace
                replace = (replace + 1) % frames.length;
            }
        }

        return numPageFaults;
    }

    /**
     * Searches for a page in memory
     *
     * @param frames The array of pages to search
     * @param page The page to be found
     * @return The index of page in frame, or -1 if not found
     */
    private static int isInArray(int[] frames, int page) {
        for(int i = 0; i < frames.length; i++) {
            if(frames[i] == page) return i;
        }
        return -1;
    }

    /**
     * Searches for a page in memory
     * Specific to the Second Chance algorithm implementation only
     *
     * @param frames The array of pages to search
     * @param page The page to be found
     * @return The index of page in frame, or -1 if not found
     */
    private  static int isInArray(int[][] frames, int page) {
        for (int i = 0; i < frames.length; i++) {
            if(frames[i][0] == page) return i;
        }
        return -1;
    }

    /**
     * Displays the raw number of page faults per algorithm
     * Displays a bar graph comparing relative number of page faults per algorithm
     *
     * @param optimal The page faults of the Optimal algorithm
     * @param lru The page faults of the LRU algorithm
     * @param secondChance The page faults of the Second Chance algorithm
     * @param fifo The page faults of the FIFO algorithm
     */
    private static void displayResults(int optimal, int lru, int secondChance, int fifo) {
        // Display raw number of page faults per algorithm
        System.out.println("\n\n*** Page Faults Generated *** ");
        System.out.println("   Optimal: " + optimal);
        System.out.println("       LRU: " + lru);
        System.out.println("2nd Chance: " + secondChance);
        System.out.println("      FIFO: " + fifo);

        // Process values for graphing so fifo is always 50
        int graphMax = 50;
        double x = fifo / (double) graphMax;
        optimal /= x;
        lru /= x;
        secondChance /= x;
        fifo = graphMax;
        char barChar = '#';

        // Display bar graph of relative number of page faults
        System.out.println("\n*** Relative Number of Faults Generated ***");
        System.out.println("   Optimal: " + barGraph(optimal, barChar));
        System.out.println("       LRU: " + barGraph(lru, barChar));
        System.out.println("2nd Chance: " + barGraph(secondChance, barChar));
        System.out.println("      FIFO: " + barGraph(fifo, barChar) + "\n");
    }

    /**
     * Builds a bar to be displayed in a bar graph
     *
     * @param length The length of the bar (in characters)
     * @param c A character to build the bar
     * @return A String of c chars repeated length times
     */
    private static String barGraph(int length, char c) {
        return String.valueOf(c).repeat(Math.max(0, length));
    }
}


/*
SAMPLE RUN

Enter size of virtual memory:
4096
Enter length of reference string:
10000
Enter size of locus:
20
Enter rate of motion:
50
Enter probability of transition:
.1
Enter number of frames:
10


*** Page Faults Generated ***
   Optimal: 2601
       LRU: 5117
2nd Chance: 5094
      FIFO: 5089

*** Relative Number of Faults Generated ***
   Optimal: #########################
       LRU: ##################################################
2nd Chance: ##################################################
      FIFO: ##################################################

Do you want to run another test? Y/N
Y

Enter size of virtual memory:
4096
Enter length of reference string:
10000
Enter size of locus:
10
Enter rate of motion:
1000
Enter probability of transition:
.1
Enter number of frames:
10


*** Page Faults Generated ***
   Optimal: 19
       LRU: 29
2nd Chance: 27
      FIFO: 48

*** Relative Number of Faults Generated ***
   Optimal: ###################
       LRU: ##############################
2nd Chance: ############################
      FIFO: ##################################################

Do you want to run another test? Y/N
Y

Enter size of virtual memory:
4096
Enter length of reference string:
10000
Enter size of locus:
1000
Enter rate of motion:
10
Enter probability of transition:
.1
Enter number of frames:
10


*** Page Faults Generated ***
   Optimal: 9147
       LRU: 9906
2nd Chance: 9906
      FIFO: 9906

*** Relative Number of Faults Generated ***
   Optimal: ##############################################
       LRU: ##################################################
2nd Chance: ##################################################
      FIFO: ##################################################

Do you want to run another test? Y/N
Y

Enter size of virtual memory:
4096
Enter length of reference string:
10000
Enter size of locus:
10
Enter rate of motion:
100
Enter probability of transition:
.1
Enter number of frames:
10


*** Page Faults Generated ***
   Optimal: 208
       LRU: 310
2nd Chance: 383
      FIFO: 570

*** Relative Number of Faults Generated ***
   Optimal: ##################
       LRU: ###########################
2nd Chance: #################################
      FIFO: ##################################################

Do you want to run another test? Y/N
n

Process finished with exit code 0
 */